@page "/exchangerates"
@using Microsoft.AspNetCore.Components.QuickGrid
@using BlazorApp01.Web.Services
@inject IExchangeRateService ExchangeRateService
@inject IDateTimeHelper DateTimeHelper
@rendermode InteractiveServer

<PageTitle>Exchange Rates</PageTitle>

<h1>EUR → USD Exchange Rates</h1>

<div class="mb-3">
    <label>Start Date: <input type="date" @bind="startDate" class="form-control" /></label>
    <label>End Date: <input type="date" @bind="endDate" class="form-control" /></label>
    <button class="btn btn-primary mt-2" @onclick="LoadRatesAsync">Load</button>
</div>

@if (!string.IsNullOrEmpty(errorMessage))
{
    <div class="alert alert-danger">@errorMessage</div>
}

@if (loading)
{
    <p><em>Loading...</em></p>
}
else if (rates == null || rates.Length == 0)
{
    <p>No data</p>
}
else
{
    <div style="height:300px">
        <canvas id="exchangeChart" style="width:100%;height:100%;"></canvas>
    </div>

    <QuickGrid Class="table mt-3" ItemsProvider="ratesProvider" Pagination="pagination">
        <PropertyColumn Property="r => r.DateTimeUtc" Title="Date (UTC)" Sortable="true" />
        <PropertyColumn Property="r => r.Rate" Title="Rate (EUR→USD)" Sortable="true" Format="F6" />
    </QuickGrid>
    <Paginator State="pagination" />
}

@code {
    private DateTime startDate = DateTime.UtcNow.AddDays(-7);
    private DateTime endDate = DateTime.UtcNow;

    private bool loading;
    private ExchangeRatePoint[]? rates;
    private bool shouldRenderChart;
    private string? errorMessage;

    private PaginationState pagination = new PaginationState { ItemsPerPage = 10 };
    private GridItemsProvider<ExchangeRatePoint>? ratesProvider;

    protected override void OnInitialized()
    {
        ratesProvider = async request =>
        {
            // apply sorting
            var items = rates ?? Array.Empty<ExchangeRatePoint>();
            IEnumerable<ExchangeRatePoint> q = items;
            if (request.GetSortByProperties().Any())
            {
                var p = request.GetSortByProperties().First();
                if (p.PropertyName == nameof(ExchangeRatePoint.DateTimeUtc))
                {
                    q = p.Direction == SortDirection.Ascending ? q.OrderBy(x => x.DateTimeUtc) : q.OrderByDescending(x => x.DateTimeUtc);
                }
                else if (p.PropertyName == nameof(ExchangeRatePoint.Rate))
                {
                    q = p.Direction == SortDirection.Ascending ? q.OrderBy(x => x.Rate) : q.OrderByDescending(x => x.Rate);
                }
            }

            var result = q.Skip(request.StartIndex).Take(request.Count ?? pagination.ItemsPerPage).ToList();
            return GridItemsProviderResult.From(result, items.Length);
        };
    }

    private async Task LoadRatesAsync()
    {
        loading = true;
        errorMessage = null;
        StateHasChanged();

        try
        {
            var pts = await ExchangeRateService.GetRatesAsync(startDate, endDate);
            rates = pts.Select(p => new ExchangeRatePoint(p.DateTimeUtc, p.Rate, p.CreatedAt)).ToArray();
            // Defer chart rendering until after the component has rendered the canvas element
            shouldRenderChart = true;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            errorMessage = ex.Message;
        }
        finally
        {
            loading = false;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (shouldRenderChart)
        {
            shouldRenderChart = false;
            // Ensure rates is not null
            if (rates != null && rates.Length > 0)
            {
                // Serialize to JSON string to ensure a predictable shape arrives in JS
                var payload = System.Text.Json.JsonSerializer.Serialize(rates.Select(r => new { date = r.DateTimeUtc.ToString("o"), rate = r.Rate }).ToArray());
                // Log payload server-side to help debugging (visible in application output)
                //Console.WriteLine($"ExchangeRates: sending payload with {rates.Length} points: {payload}");

                try
                {
                    // Call the global shim which will import the module and render; this avoids direct import issues
                    await JSRuntime.InvokeVoidAsync("exchangeChartInterop.render", payload);
                }
                catch (Exception ex)
                {
                    errorMessage = "Chart rendering error: " + ex.Message;
                    //Console.WriteLine("ExchangeRates: exchangeChartInterop.invoke failed: " + ex);
                }
            }
        }
    }

    [Inject]
    private IJSRuntime JSRuntime { get; set; } = default!;

    private IJSObjectReference? chartModule;

    public async ValueTask DisposeAsync()
    {
        if (chartModule != null)
        {
            await chartModule.DisposeAsync();
        }
    }

    private sealed record ExchangeRatePoint(DateTime DateTimeUtc, decimal Rate, DateTime CreatedAt);
}
