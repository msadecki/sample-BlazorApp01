@page "/exchangerates"
@using Microsoft.AspNetCore.Components.QuickGrid
@using BlazorApp01.Web.Services
@inject IExchangeRateService ExchangeRateService
@inject IDateTimeHelper DateTimeHelper
@rendermode InteractiveServer

<PageTitle>Exchange Rates</PageTitle>

<h1>@fromCurrency â†’ @toCurrency Exchange Rates</h1>

<div class="mb-3">
    <div class="row g-2 align-items-end">
        <div class="col-md-3">
            <label class="form-label">From</label>
            <select class="form-select" @bind="fromCurrency">
                @if (currencies != null)
                {
                    @foreach (var c in currencies)
                    {
                        <option value="@c.Code" disabled="@(c.Code == toCurrency)" selected="@(c.Code == fromCurrency)">@c.Code - @c.Name</option>
                    }
                }
                else
                {
                    <option value="EUR">EUR</option>
                }
            </select>
        </div>

        <div class="col-md-3">
            <label class="form-label">To</label>
            <select class="form-select" @bind="toCurrency">
                @if (currencies != null)
                {
                    @foreach (var c in currencies)
                    {
                        <option value="@c.Code" disabled="@(c.Code == fromCurrency)" selected="@(c.Code == toCurrency)">@c.Code - @c.Name</option>
                    }
                }
                else
                {
                    <option value="USD">USD</option>
                }
            </select>
        </div>

        <div class="col-md-3">
            <label class="form-label">Start Date</label>
            <input type="date" @bind="startDate" class="form-control" />
        </div>

        <div class="col-md-3">
            <label class="form-label">End Date</label>
            <input type="date" @bind="endDate" class="form-control" />
        </div>
    </div>

    <div class="mt-2">
        <button class="btn btn-outline-secondary me-2" @onclick="() => { var tmp = fromCurrency; fromCurrency = toCurrency; toCurrency = tmp; rates = null; StateHasChanged(); }">Swap</button>
        <button class="btn btn-primary" @onclick="LoadRatesAsync">Load</button>
    </div>
</div>

@if (!string.IsNullOrEmpty(errorMessage))
{
    <div class="alert alert-danger">@errorMessage</div>
}

@if (loading)
{
    <p><em>Loading...</em></p>
}
else if (rates == null || rates.Count == 0)
{
    <p>No data</p>
}
else
{
    <div style="height:300px">
        <canvas id="exchangeChart" style="width:100%;height:100%;"></canvas>
    </div>

    <QuickGrid Class="table mt-3" ItemsProvider="ratesProvider" Pagination="pagination">
        <PropertyColumn Property="point => point.Date" Title="Date" Sortable="true" />
        <PropertyColumn Property="point => point.Rate" Title="Rate" Sortable="true" Format="F6" />
    </QuickGrid>
    <Paginator State="pagination" />
}

@code {
    private DateTime startDate = DateTime.UtcNow.AddDays(-7);
    private DateTime endDate = DateTime.UtcNow;

    private bool loading;
    private IReadOnlyList<ExchangeRatePoint>? rates;
    private IReadOnlyList<CurrencyInfo>? currencies;
    private bool shouldRenderChart;
    private string? errorMessage;

    private PaginationState pagination = new PaginationState { ItemsPerPage = 10 };
    private GridItemsProvider<ExchangeRatePoint>? ratesProvider;
    private string fromCurrency = "EUR";
    private string toCurrency = "USD";

    protected override async Task OnInitializedAsync()
    {
        await LoadCurrenciesAsync();

        ratesProvider = async request =>
        {
            // apply sorting
            var items = rates ?? Array.Empty<ExchangeRatePoint>();
            IEnumerable<ExchangeRatePoint> q = items;
            if (request.GetSortByProperties().Any())
            {
                var p = request.GetSortByProperties().First();
                if (p.PropertyName == nameof(ExchangeRatePoint.Date))
                {
                    q = p.Direction == SortDirection.Ascending ? q.OrderBy(x => x.Date) : q.OrderByDescending(x => x.Date);
                }
                else if (p.PropertyName == nameof(ExchangeRatePoint.Rate))
                {
                    q = p.Direction == SortDirection.Ascending ? q.OrderBy(x => x.Rate) : q.OrderByDescending(x => x.Rate);
                }
            }

            var result = q.Skip(request.StartIndex).Take(request.Count ?? pagination.ItemsPerPage).ToList();
            return GridItemsProviderResult.From(result, items.Count);
        };
    }

    private async Task LoadRatesAsync()
    {
        loading = true;
        errorMessage = null;
        StateHasChanged();

        try
        {
            rates = await ExchangeRateService.GetRatesAsync(startDate, endDate, fromCurrency, toCurrency);
            // Defer chart rendering until after the component has rendered the canvas element
            shouldRenderChart = true;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            errorMessage = ex.Message;
        }
        finally
        {
            loading = false;
        }
    }

    private async Task LoadCurrenciesAsync()
    {
        try
        {
            currencies = await ExchangeRateService.GetCurrenciesAsync();

            // Prefer explicit EUR -> USD defaults when available in the returned list.
            if (currencies.Any(c => c.Code == "EUR"))
            {
                fromCurrency = "EUR";
            }
            else
            {
                fromCurrency = currencies.FirstOrDefault()?.Code ?? "EUR";
            }

            if (currencies.Any(c => c.Code == "USD"))
            {
                toCurrency = "USD";
            }
            else
            {
                // pick a different currency than `fromCurrency` if possible
                toCurrency = currencies.FirstOrDefault(c => c.Code != fromCurrency)?.Code ?? fromCurrency;
            }

            StateHasChanged();
        }
        catch (Exception ex)
        {
            // non-fatal: keep defaults
            errorMessage = "Unable to load currencies: " + ex.Message;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (shouldRenderChart)
        {
            shouldRenderChart = false;
            // Ensure rates is not null
            if (rates != null && rates.Count > 0)
            {
                // Serialize to JSON string to ensure a predictable shape arrives in JS
                var fromName = currencies?.FirstOrDefault(c => c.Code == fromCurrency)?.Name ?? fromCurrency;
                var toName = currencies?.FirstOrDefault(c => c.Code == toCurrency)?.Name ?? toCurrency;

                var payloadObj = new
                {
                    from = new { code = fromCurrency, name = fromName },
                    to = new { code = toCurrency, name = toName },
                    points = rates.Select(r => new { date = r.Date.ToString("o"), rate = r.Rate }).ToArray()
                };

                var payload = System.Text.Json.JsonSerializer.Serialize(payloadObj);
                // Log payload server-side to help debugging (visible in application output)
                //Console.WriteLine($"ExchangeRates: sending payload with {rates.Length} points: {payload}");

                try
                {
                    // Call the global shim which will import the module and render; this avoids direct import issues
                    await JSRuntime.InvokeVoidAsync("exchangeChartInterop.render", payload);
                }
                catch (Exception ex)
                {
                    errorMessage = "Chart rendering error: " + ex.Message;
                    //Console.WriteLine("ExchangeRates: exchangeChartInterop.invoke failed: " + ex);
                }
            }
        }
    }

    [Inject]
    private IJSRuntime JSRuntime { get; set; } = default!;

    private IJSObjectReference? chartModule;

    public async ValueTask DisposeAsync()
    {
        if (chartModule != null)
        {
            await chartModule.DisposeAsync();
        }
    }
}
