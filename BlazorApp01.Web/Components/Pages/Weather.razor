@page "/weather"
@using Microsoft.AspNetCore.Components.QuickGrid
@using BlazorApp01.Web.Services
@using System.Globalization
@inject IDateTimeHelper DateTimeHelper
@inject IWeatherService WeatherService
@rendermode InteractiveServer

<PageTitle>Weather</PageTitle>

<h1>Weather</h1>

<p>This component demonstrates showing data with user time zone conversion. It uses free weather forecast API data feed (open-meteo.com).</p>

@if (forecasts == null)
{
    <p><em>Loading...</em></p>
}
else
{
    <QuickGrid Class="table" Items="@forecasts.AsQueryable()">
        <PropertyColumn Property="@(forecast => forecast.DateAtUserTZ)" Title="Date (User TZ)" Sortable="true" />
        @* <PropertyColumn Property="@(forecast => forecast.DateTimeAtUserTZ)" Title="Date Time (User TZ)" Sortable="true" /> *@
        <PropertyColumn Property="@(forecast => forecast.SunriseAtUserTZ)" Title="Sunrise (User TZ)" Sortable="true" />
        <PropertyColumn Property="@(forecast => forecast.SunsetAtUserTZ)" Title="Sunset (User TZ)" Sortable="true" />
        @* <PropertyColumn Property="@(forecast => forecast.CreatedAtUserTZ)" Title="Created (User TZ)" Sortable="true" /> *@
        <PropertyColumn Property="@(forecast => forecast.TemperatureMin)" Title="Temp. Min (C)" Sortable="true" Format="F1" />
        <PropertyColumn Property="@(forecast => forecast.TemperatureMax)" Title="Temp. Max (C)" Sortable="true" Format="F1" />
        @* <PropertyColumn Property="@(forecast => forecast.TemperatureC)" Title="Temp. (C)" Sortable="true" /> *@
        @* <PropertyColumn Property="@(forecast => forecast.TemperatureF)" Title="Temp. (F)" Sortable="true" /> *@
        <PropertyColumn Property="@(forecast => forecast.PrecipitationSum)" Title="Precip. (mm)" Sortable="true" Format="F1" />
        <PropertyColumn Property="@(forecast => forecast.PrecipitationProbabilityMax)" Title="Precip. Prob (%)" Sortable="true" />
        <PropertyColumn Property="@(forecast => forecast.WindSpeedMax)" Title="Wind Max (m/s)" Sortable="true" Format="F1" />
        @* <PropertyColumn Property="@(forecast => forecast.WeatherCode)" Title="Weather Code" Sortable="true" /> *@
        <PropertyColumn Property="@(forecast => forecast.WeatherDescription)" Title="Weather Description" Sortable="true" />
    </QuickGrid>
}

<div class="location-selector" style="margin-top:1rem">
    <h3>Location</h3>
    <div style="display:flex;gap:0.5rem;align-items:center;flex-wrap:wrap">
        <label>Latitude:
            <input type="number" step="0.000001" @bind="latitude" />
        </label>
        <label>Longitude:
            <input type="number" step="0.000001" @bind="longitude" />
        </label>
        <button class="btn btn-primary" @onclick="LoadForecastsAsync">Get Forecast</button>
    </div>

    <div style="margin-top:0.5rem">
        <div id="map" style="height:300px;border:1px solid #ccc"></div>
    </div>
</div>

@code {
    private WeatherForecast[]? forecasts;
    private double latitude = 52.23224240174998;
    private double longitude = 20.93381175935411;
    [Inject]
    private IJSRuntime? JSRuntime { get; set; }

    private DotNetObjectReference<Weather>? dotNetRef;
    private bool needsMapUpdate;
    private bool mapInitPending = true;
    private bool mapInitialized;
    private IJSObjectReference? mapModule;

    protected override async Task OnInitializedAsync()
    {
        await LoadForecastsAsync();
    }

    private async Task LoadForecastsAsync()
    {
        // Load real data from the weather service using currently selected location
        var points = await WeatherService.GetForecastsAsync(days: 14, latitude: latitude, longitude: longitude);
        forecasts = points.Select(point => new WeatherForecast(DateTimeHelper)
        {
            DateTimeUtc = point.DateTime,
            TemperatureMin = point.TemperatureMin,
            TemperatureMax = point.TemperatureMax,
            TemperatureC = point.TemperatureC,
            PrecipitationSum = point.PrecipitationSum,
            PrecipitationProbabilityMax = point.PrecipitationProbabilityMax,
            WindSpeedMax = point.WindSpeedMax,
            WeatherCode = point.WeatherCode,
            WeatherDescription = point.WeatherDescription,
            SunriseUtc = point.Sunrise,
            SunsetUtc = point.Sunset,
            CreatedAtUtc = point.CreatedAt
        }).ToArray();

        // Request map update after render (JS interop not allowed during prerender/OnInitialized)
        needsMapUpdate = true;
        StateHasChanged();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Try to initialize the map when JS interop is available. When prerendering, JS interop calls
        // will throw InvalidOperationException. We catch that and retry on the next render.
        if (mapInitPending)
        {
            if (JSRuntime is not null)
            {
                try
                {
                    dotNetRef ??= DotNetObjectReference.Create(this);
                    // Import the ES module. This may fail during prerender; catch and retry.
                    mapModule ??= await JSRuntime.InvokeAsync<IJSObjectReference>("import", "/js/weatherMap.js");
                    await mapModule.InvokeVoidAsync("init", "map", latitude, longitude, dotNetRef);
                    mapInitialized = true;
                    mapInitPending = false;
                }
                catch (JSException)
                {
                    // JS interop not available yet or module not loaded. Keep pending so we'll retry later.
                    mapInitialized = false;
                    mapInitPending = true;
                }
                catch (InvalidOperationException)
                {
                    mapInitialized = false;
                    mapInitPending = true;
                }
            }
        }

        if (mapInitialized && needsMapUpdate && mapModule is not null)
        {
            try
            {
                needsMapUpdate = false;
                await mapModule.InvokeVoidAsync("setLocation", "map", latitude, longitude);
            }
            catch (JSException)
            {
                // JS interop not available right now; keep update requested for next render
                needsMapUpdate = true;
            }
        }
    }

    [JSInvokable]
    public async Task NotifyLocationChanged(double lat, double lon)
    {
        // Called from JS when user clicks or drags the marker on the map
        latitude = lat;
        longitude = lon;
        await LoadForecastsAsync();
        StateHasChanged();
    }

    public void Dispose()
    {
        dotNetRef?.Dispose();
    }

    public async ValueTask DisposeAsync()
    {
        try
        {
            if (mapModule is not null)
            {
                await mapModule.DisposeAsync();
            }
        }
        catch
        {
            // ignore
        }

        dotNetRef?.Dispose();
    }

        private sealed class WeatherForecast(IDateTimeHelper dateTimeHelper)
        {
            public required DateTime DateTimeUtc { get; init; }
            public required decimal TemperatureMin { get; init; }
            public required decimal TemperatureMax { get; init; }
            public required int TemperatureC { get; init; }
            public required decimal PrecipitationSum { get; init; }
            public required int PrecipitationProbabilityMax { get; init; }
            public required decimal WindSpeedMax { get; init; }
            public required int WeatherCode { get; init; }
            public required string WeatherDescription { get; init; }
            public required DateTime? SunriseUtc { get; init; }
            public required DateTime? SunsetUtc { get; init; }
            public required DateTime CreatedAtUtc { get; init; }

            public int TemperatureF => 32 + (int)(TemperatureC / 0.5556);
            public string DateTimeAtUserTZ => dateTimeHelper.ConvertToFormattedUserDateTime(DateTimeUtc);
            public string DateAtUserTZ => dateTimeHelper.ConvertToFormattedUserDate(DateTimeUtc);
            public string SunriseAtUserTZ => dateTimeHelper.ConvertToFormattedUserDateTime(SunriseUtc);
            public string SunsetAtUserTZ => dateTimeHelper.ConvertToFormattedUserDateTime(SunsetUtc);
            public string CreatedAtUserTZ => dateTimeHelper.ConvertToFormattedUserDateTime(CreatedAtUtc);
        }
}
